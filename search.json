[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Estatística descritiva (1ed)",
    "section": "",
    "text": "Bem-vindos",
    "crumbs": [
      "Bem-vindos"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referências",
    "section": "",
    "text": "Chambers, John M. 2014. “Object-Oriented\nProgramming, Functional\nProgramming and R.” Statistical\nScience 29 (2). https://doi.org/10.1214/13-STS452.\n\n\nHalmos, Paul R. 2001. Teoria Ingenua Dos Conjuntos. Rio de\nJaneiro: Editora Ciencia Moderna.\n\n\nIsmay, Chester, and Albert Young-Sun Kim. 2020. Statistical\nInference via Data Science: A ModernDive into\nR and the Tidyverse. Chapman &\nHall/CRC the R\nSeries. Boca Raton: CRC Press / Taylor & Francis Group.\nhttps://moderndive.com/.\n\n\nWickham, Hadley. 2019. Advanced R. Second edition.\nChapman & Hall/CRC: The\nR Series. Boca Raton London New York: CRC Press, Taylor\n& Francis Group. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Referências"
    ]
  },
  {
    "objectID": "getting_started_with_r.html",
    "href": "getting_started_with_r.html",
    "title": "Apêndice A — Introdução ao R",
    "section": "",
    "text": "A.1 R e RStudio IDE\nO  é como o motor de um carro, enquanto o RStudio IDE funciona como o volante e o painel, conforme ilustrado na Figura A.1. Assim como um motorista interage principalmente com o volante e o painel para controlar o carro, raramente precisando interagir diretamente com o motor, o RStudio IDE também oferece uma interface amigável para trabalhar com o poderoso mecanismo do . Essa interface simplifica o processo de usar o  para suas tarefas.",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "getting_started_with_r.html#r-e-rstudio-ide",
    "href": "getting_started_with_r.html#r-e-rstudio-ide",
    "title": "Apêndice A — Introdução ao R",
    "section": "",
    "text": "(a) R: Motor\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n(b) RStudio IDE: Painel\n\n\n\n\n\n\n\nFigura A.1: Analogia da diferença entre  e RStudio",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "getting_started_with_r.html#como-baixar-e-instalar-o-r",
    "href": "getting_started_with_r.html#como-baixar-e-instalar-o-r",
    "title": "Apêndice A — Introdução ao R",
    "section": "A.2 Como baixar e instalar o R",
    "text": "A.2 Como baixar e instalar o R\nPara obter uma cópia e a versão oficial mais recente do , acesse The Comprehensive R Archive Network (CRAN). O  é desenvolvido para as famílias de sistemas operacionais Unix, Windows e Mac. Na CRAN, você encontrará 3 links para baixar o  para Linux, macOS ou Windows:\n\n: Clique em Download R for Linux, escolha sua distribuição e siga as instruções de instalação específicas para sua distribuição.\n: Clique em Download R for macOS. Selecione o instalador que corresponda à sua versão do macOS, abra-o e siga as instruções na tela.\n: Clique em Download R for Windows e, em seguida, clique em base. Depois, clique no primeiro link no topo da nova página e execute o instalador. O instalador irá guiá-lo através do processo de instalação.",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "getting_started_with_r.html#como-baixar-e-instalar-o-rstudio-ide",
    "href": "getting_started_with_r.html#como-baixar-e-instalar-o-rstudio-ide",
    "title": "Apêndice A — Introdução ao R",
    "section": "A.3 Como baixar e instalar o RStudio IDE",
    "text": "A.3 Como baixar e instalar o RStudio IDE\nPara obter a versão oficial mais recente do RStudio IDE, acesse https://posit.co/download/rstudio-desktop/. Role a página para baixo, selecione seu sistema operacional e baixe o instalador apropriado. Abra o instalador e siga as instruções fornecidas.\nAgora que você instalou o  e o RStudio IDE, você está pronto para começar a trabalhar no RStudio IDE. Assim como você interage principalmente com o volante e o painel de um carro em vez do motor, você focará em usar a interface do RStudio IDE para trabalhar com o .\nAo abrir o RStudio IDE, você pode criar um novo script  selecionando File &gt; New File &gt; R Script ou usando o atalho de teclado Ctrl + Shift + N. Você verá quatro painéis principais na interface, como mostrado na Figura A.2:\n\nPainel 1: É onde você escreve, edita e salva seu código R.\nPainel 2: Aqui você pode digitar os comandos do R e ver os resultados.\nPainel 3: Este painel mostra os objetos do R (como variáveis ou dados) que você criou durante a sessão atual.\nPainel 4: Vários elementos de saída, incluindo arquivos, gráficos e documentos de ajuda, são exibidos aqui.\n\n\n\n\n\n\n\nFigura A.2: Painéis do RStudio IDE\n\n\n\n\nA.3.1 Configurar e personalizar o RStudio IDE\nPara personalizar seu espaço de trabalho, acesse Tools &gt; Global Options. Em seguida:\n\nSempre inicie o  com uma sessão em branco, Figura A.3:\n\n\n\n\n\n\n\nFigura A.3: Configuração do espaço de trabalho\n\n\n\n\nUse o operador de pipe nativo, |&gt;, Figura A.4:\n\n\n\n\n\n\n\nFigura A.4: Configuração para usar o operador de pipe nativo\n\n\n\n\nAjuste o tamanho da fonte e selecione um tema escuro, Figura A.5:\n\n\n\n\n\n\n\nFigura A.5: Configuração para usar um tema escuro\n\n\n\nA aplicação dessas mudanças personalizará sua experiência com o RStudio IDE, como mostrado na Figura A.6.\n\n\n\n\n\n\nFigura A.6: Resultado da aplicação da configuração completa",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "getting_started_with_r.html#executar-código-usando-o-rstudio-ide",
    "href": "getting_started_with_r.html#executar-código-usando-o-rstudio-ide",
    "title": "Apêndice A — Introdução ao R",
    "section": "A.4 Executar código usando o RStudio IDE",
    "text": "A.4 Executar código usando o RStudio IDE\nPara nos comunicarmos com uma máquina, escrevemos instruções em uma linguagem especializada chamada código. Este código é então traduzido em um formato que a máquina entende, permitindo que ela execute as tarefas que definimos.\nVamos começar com um exemplo simples! Digite 1 + 2 + 3 + 4 + 5 + 6, como mostrado na Figura A.7, e então aperte Enter para ver o que acontece!\n\n\n\n\n\n\nFigura A.7: Executando código no console\n\n\n\nSe você seguiu as instruções certinho, o RStudio IDE vai mostrar o seguinte resultado:\n\n1 + 2 + 3 + 4 + 5 + 6\n#&gt; [1] 21\n\nAo executar o código, você pode encontrar mensagens , avisos ou erros. Não entre em pânico! Estas são maneiras do seu computador se comunicar com você:\n\nMensagem (Message): É simplesmente uma nota informativa. Seu código ainda será executado sem problemas.\nAviso (Warning): Alerta você sobre potenciais resultados inesperados, mas seu código ainda será executado.\nErro (Error): Indica um problema fundamental que impede o seu código de ser executado. Você precisará corrigir o problema para que seu código possa funcionar.\n\nMais adiante, você usará o comando install.packages(), onde poderá encontrar mensagens. Para avisos ou erros, tente os seguintes comandos para ilustrar as diferenças:\n\nlog(x = -1)\n#&gt; Warning in log(x = -1): NaNs produced\n#&gt; [1] NaN\n\n\n\"Tudo bem\" * 2\n#&gt; Error in \"Tudo bem\" * 2: non-numeric argument to binary operator\n\nNo primeiro caso, o código será executado, mas você verá o resultado NaN (Not a Number, em inglês) porque o logaritmo de um número negativo é indefinido. No segundo caso, seu código não será executado porque o  não permite a multiplicação de palavras.\n\n\n\n\n\n\nNota\n\n\n\nNo , uma string é uma coleção de um ou mais caracteres e são criadas usando aspas duplas, \"\". Por exemplo, \"Tudo bem\" é uma string.",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "getting_started_with_r.html#objetos-funções-e-o-operador-de-atribuição",
    "href": "getting_started_with_r.html#objetos-funções-e-o-operador-de-atribuição",
    "title": "Apêndice A — Introdução ao R",
    "section": "A.5 Objetos, funções e o operador de atribuição",
    "text": "A.5 Objetos, funções e o operador de atribuição\nTudo que existe no  é um objeto (Chambers 2014, 170). Isso significa que números, textos e até mesmo instruções para o computador são todos tratados como objetos. Você manipula esses objetos usando funções, que recebem objetos como entrada e produzem novos objetos como saída.\nPor exemplo, quando você soma os números 1, 2, 3, 4, 5 e 6 (que são objetos), você usa a função + repetidamente para criar um novo objeto 21. O  é construído sobre a ideia de que objetos e funções trabalham juntos.\nPara trabalhar com objetos de forma simples, você pode atribuir nomes a eles usando o operador &lt;-. Uma vez que um objeto tenha um nome, você pode manipulá-lo chamando esse nome.\nPara entender esses conceitos de maneira prática, vamos considerar o processo de jogar uma moeda usando o .\n\nA.5.1 Objeto moeda\nVamos imaginar uma moeda padrão com dois lados: cara e coroa, como mostrado na Figura A.8.\n\n\n\n\n\n\nFigura A.8: Os dois lados de uma moeda\n\n\n\nPara simular um lançamento de moeda em , primeiro precisamos criar um objeto que represente nossa moeda com seus dois lados: cara e coroa. Vamos atribuir um nome a esse objeto usando &lt;-. Veja como combinar esses elementos em R usando a função c():\n\nmoeda &lt;- c(\"cara\", \"coroa\")\n\n\n\n\n\n\n\nNota\n\n\n\nPara representar os dois lados da moeda, usamos duas strings: \"cara\" e \"coroa\". Usar apenas cara e coroa sem aspas duplas poderia causar problemas, pois o  as interpretaria como nomes associados a alguns objetos, em vez de valores representando os dois lados da moeda.\n\n\nAgora que associamos um nome ao nosso objeto moeda, podemos manipulá-lo simplesmente chamando o nome moeda:\n\nmoeda\n#&gt; [1] \"cara\"  \"coroa\"\n\nQuando um objeto tem um nome, ele aparecerá na aba Ambiente (Environment, em inglês) do painel 3 no RStudio IDE, como mostrado na Figura A.9.\n\n\n\n\n\n\nFigura A.9: Aba de ambiente\n\n\n\n\n\nA.5.2 Jogar uma moeda\nAgora que você criou um objeto no , é hora de simular o lançamento de uma moeda. Uma maneira de fazer isso é com a função sample:\n\nsample(x = moeda, size = 1)\n#&gt; [1] \"coroa\"\n\nAqui, o argumento x informa à função qual objeto usar para selecionar os elementos. O argumento size especifica quantos elementos escolher, neste caso size = 1 para representar o lançamento de uma única moeda.\nVamos tentar jogar a moeda duas vezes:\n\nsample(x = moeda, size = 2)\n#&gt; [1] \"cara\"  \"coroa\"\n\nE que tal 3 vezes?\n\nsample(x = moeda, size = 3)\n#&gt; Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n\nVocê encontrará um erro. Não se preocupe, os erros são úteis. A mensagem de erro menciona o argumento replace. Para aprender mais sobre qualquer função, use ? seguido do nome da função, como ?sample, conforme mostrado na Figura 1.\n\n\n\n\n\n\nFigura A.10\n\n\n\nQuando replace = FALSE, cada item em x só pode ser escolhido uma vez. Para simular vários lançamentos de uma moeda, em que cada resultado tem a mesma probabilidade de ser selecionado a cada vez, replace = TRUE:\n\nsample(x = moeda, size = 3, replace = TRUE)\n#&gt; [1] \"coroa\" \"coroa\" \"coroa\"\n\nAgora temos todos os componentes para construir uma função na próxima seção. Comecemos simulando quatro lançamentos de uma moeda:\n\nlados &lt;- c(\"cara\", \"coroa\")\nn_lancamentos &lt;- 4\ncom_reposicao &lt;- TRUE\nlancamentos &lt;- sample(x = lados, size = n_lancamentos, replace = com_reposicao)\nlancamentos\n#&gt; [1] \"coroa\" \"cara\"  \"cara\"  \"coroa\"\n\n\n\n\n\n\n\nImportante\n\n\n\nPara melhorar a legibilidade do código, seguiremos estas diretrizes:\n\nNomes de objetos: Use apenas letras minúsculas sem acentos, números e sublinhados, _, para nomes de objetos.\nSeparação de palavras: Utilize sublinhados para separar palavras dentro de um nome (isso é conhecido como snake case).\nNomes significativos: Escolha nomes de objetos que reflitam com precisão o que eles representam.\n\n\n\n\n\nA.5.3 Definindo novas funções\nNo , uma função tem três partes básicas: um nome, um corpo e um conjunto de argumentos1. Para criar uma, usamos a função function, seguindo esta estrutura:\n\nnome &lt;- function(argumentos) {\n  corpo\n}\n\nVamos construir nossa função de lançamento de uma moeda passo a passo. Por enquanto, começaremos sem usar argumentos:\n\njogar_moeda &lt;- function() {\n  \n  lados &lt;- c(\"cara\", \"coroa\")\n  n_lancamentos &lt;- 4\n  com_reposicao &lt;- TRUE\n  lancamentos &lt;- sample(x = lados, \n                        size = n_lancamentos, \n                        replace = com_reposicao)\n  \n  return(lancamentos)\n}\n\n\n\n\n\n\n\nDica\n\n\n\nEm uma função bem estruturada, usamos a declaração return no final do corpo para especificar explicitamente o valor que queremos que a função retorne. Isso é considerado uma boa prática na programação em .\n\n\nCopie e cole o código acima no console, pressione Enter e verifique a aba Ambiente (Environment, em inglês) do RStudio IDE, como mostrado na Figura 2.\n\n\n\n\n\n\nFigura A.11\n\n\n\nAgora vamos ver se a função realmente funciona:\n\njogar_moeda()\n#&gt; [1] \"coroa\" \"coroa\" \"coroa\" \"cara\"\n\nVocê pode se perguntar: Por que não usar simplesmente jogar_moeda? Vamos tentar e ver o que acontece:\n\njogar_moeda\n#&gt; function() {\n#&gt;   \n#&gt;   lados &lt;- c(\"cara\", \"coroa\")\n#&gt;   n_lancamentos &lt;- 4\n#&gt;   com_reposicao &lt;- TRUE\n#&gt;   lancamentos &lt;- sample(x = lados, \n#&gt;                         size = n_lancamentos, \n#&gt;                         replace = com_reposicao)\n#&gt;   \n#&gt;   return(lancamentos)\n#&gt; }\n\nNesse caso, o  vai te mostrar o código da função em vez de executá-la como faz quando você digita jogar_moeda().\n\n\nA.5.4 Argumentos\nPara tornar nossa função mais flexível, vamos permitir que o usuário especifique o número de lançamentos de moeda. Podemos fazer isso transformando n_lancamentos em um argumento da função:\n\njogar_moeda &lt;- function(n_lancamentos) {\n  \n  lados &lt;- c(\"cara\", \"coroa\")\n  com_reposicao &lt;- TRUE\n  lancamentos &lt;- sample(x = lados, \n                        size = n_lancamentos, \n                        replace = com_reposicao)\n  \n  return(lancamentos)\n}\n\nAgora, o usuário pode personalizar o número de lançamentos, especificando um valor maior ou igual a um. Vamos tentar com sete lançamentos:\n\njogar_moeda(n_lancamentos = 7)\n#&gt; [1] \"coroa\" \"cara\"  \"coroa\" \"coroa\" \"cara\"  \"coroa\" \"coroa\"\n\nTambém podemos definir valores padrão para os argumentos de uma função. Esses valores serão usados se o usuário não fornecer um valor, oferecendo flexibilidade e permitindo personalização se necessário. Vamos ilustrar essa opção definindo um valor padrão para o argumento lados:\n\njogar_moeda &lt;- function(n_lancamentos, \n                        lados = c(\"cara\", \"coroa\")) {\n  \n  com_reposicao &lt;- TRUE\n  lancamentos &lt;- sample(x = lados, \n                        size = n_lancamentos, \n                        replace = com_reposicao)\n  \n  return(lancamentos)\n}\n\nSe o usuário estiver satisfeito com as etiquetas “cara” e “coroa” para os lados da moeda, então podemos jogar uma moeda nove vezes da seguinte forma:\n\njogar_moeda(n_lancamentos = 9)\n#&gt; [1] \"cara\"  \"coroa\" \"coroa\" \"cara\"  \"coroa\" \"coroa\" \"coroa\" \"coroa\" \"coroa\"\n\nNo entanto, se o usuário quiser alterar o valor do argumento lados, mudando seus valores para refletir os lados da moeda mostrados na Figura A.8, podemos proceder da seguinte maneira:\n\njogar_moeda(n_lancamentos = 9, lados = c(\"cabeca\", \"navio\"))\n#&gt; [1] \"cabeca\" \"cabeca\" \"navio\"  \"cabeca\" \"navio\"  \"navio\"  \"navio\"  \"cabeca\"\n#&gt; [9] \"navio\"\n\n\n\n\n\nChambers, John M. 2014. “Object-Oriented Programming, Functional Programming and R”. Statistical Science 29 (2). https://doi.org/10.1214/13-STS452.\n\n\nIsmay, Chester, e Albert Young-Sun Kim. 2020. Statistical inference via data science: a ModernDive into R and the Tidyverse. Chapman & Hall/CRC the R Series. Boca Raton: CRC Press / Taylor & Francis Group. https://moderndive.com/.\n\n\nWickham, Hadley. 2019. Advanced R. Second edition. Chapman & Hall/CRC: The R series. Boca Raton London New York: CRC Press, Taylor & Francis Group. https://adv-r.hadley.nz/.",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "getting_started_with_r.html#footnotes",
    "href": "getting_started_with_r.html#footnotes",
    "title": "Apêndice A — Introdução ao R",
    "section": "",
    "text": "Funções possuem complexidades adicionais, mas vamos manter a explicação simples por enquanto. Se você ficar curioso mais tarde, confira (Wickham 2019, chap. 6) quando tiver mais experiência com o .↩︎",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "naive_set_theory.html",
    "href": "naive_set_theory.html",
    "title": "Apêndice B — Teoria ingênua dos conjuntos",
    "section": "",
    "text": "B.1 Conjuntos\nPodemos denotar um conjunto usando uma letra arbitrária como \\(A\\) e descrevê-lo listando seus elementos entre chaves. Por exemplo, \\(A = \\{ 1,2 \\}\\) é o conjunto cujos elementos são os números \\(1\\) e \\(2\\). Com base em Definição B.1 e na notação anterior, é importante fazer as seguintes observações:\nO pacote sets do  pode ser usado para ilustrar as ideias mencionadas acima para entender o conceito de conjunto. Primeiramente, podemos criar dois conjuntos e verificar se os dois conjuntos são iguais:\nlibrary(sets)\nA &lt;- set(1, 2)\nA\n#&gt; {1, 2}\nB &lt;- set(2, 1)\nB\n#&gt; {1, 2}\nA == B\n#&gt; [1] TRUE\nTambém podemos verificar a propriedade de elementos únicos em um conjunto:\nC &lt;- set(1, 1, 2, 2)\nC\n#&gt; {1, 2}\nAlém disso, podemos criar um conjunto vazio:\nvazio &lt;- set()\nvazio\n#&gt; {}\nPor último, podemos definir um conjunto cujos elementos podem ser conjuntos:\nD &lt;- set(A, 3)\nD\n#&gt; {3, {1, 2}}\nPor exemplo, se \\(A = \\{ 1 , 2 \\}\\) então \\(1 \\in A\\) e \\(3 \\notin A\\). Em , podemos verificar se um elemento pertence a um conjunto usando o operador %e% do pacote sets, que representa a relação \\(\\in\\):\n1 %e% A\n#&gt; [1] TRUE\n3 %e% A\n#&gt; [1] FALSE\nÀs vezes, não é possível listar os elementos de um conjunto porque os elementos são infinitos ou porque não sabemos exatamente quais são. No entanto, se sabemos a propriedade que cada elemento deve ter, podemos usar uma notação matemática conhecida como notação construtor de conjuntos para descrever o conjunto. Essa notação é especificada como \\(\\{ x \\in \\Omega: P(x) \\}\\), onde \\(x\\) é um elemento genérico que pertence a \\(\\Omega\\) com a propriedade \\(P(x)\\). \\(\\Omega\\)2 é conhecido como universo de discurso e se refere ao conjunto que contém todos os elementos em consideração a partir dos quais o valor de \\(x\\) pode ser escolhido. Por exemplo:\nInfelizmente, o  só pode manipular objetos que podem ser representados como números e que são finitos. Portanto, o uso de pacotes como sets não permite representar conjuntos como \\(E\\) ou \\(F\\) no .\nA Figura B.1 ilustra a Definição B.3 usando um diagrama de Venn3.\nFigura B.1: \\(A \\subseteq B\\) representado por um diagrama de Venn onde \\(\\Omega\\) é o universo de discurso\nPor exemplo, se \\(A = \\{ 1 , 2 \\}\\) e \\(G = \\{ 1, 2, 3\\}\\) então \\(A \\subseteq G\\) porque \\(1 \\in A\\), \\(1 \\in G\\), \\(2 \\in A\\) e \\(2 \\in G\\). No entanto, \\(G \\nsubseteq A\\) porque \\(3 \\in G\\) e \\(3 \\notin A\\). Em , podemos verificar se um conjunto é um subconjunto de um conjunto usando o operador &lt;= do pacote sets, que representa a relação \\(\\subseteq\\):\nG &lt;- set(1, 2, 3)\nG\n#&gt; {1, 2, 3}\nA &lt;= G\n#&gt; [1] TRUE\nG &lt;= A\n#&gt; [1] FALSE",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Teoria ingênua dos conjuntos</span>"
    ]
  },
  {
    "objectID": "naive_set_theory.html#conjuntos",
    "href": "naive_set_theory.html#conjuntos",
    "title": "Apêndice B — Teoria ingênua dos conjuntos",
    "section": "",
    "text": "Definição B.1 (Conjunto) Um conjunto é uma coleção não ordenada de elementos únicos, ou pode ser uma coleção vazia, sem nenhum elemento.\n\n\n\n\\(A = \\{ 1, 2 \\}\\) e \\(B = \\{ 2, 1 \\}\\) são o mesmo conjunto porque conjuntos são coleções não ordenadas onde a ordem não é definida.\n\\(C = \\{ 1, 1, 2, 2 \\}\\) não está bem definido porque um conjunto contém elementos únicos, onde a especificação correta seria \\(C = \\{ 1, 2 \\}\\).\nExiste um conjunto, denotado por \\(\\emptyset = \\{ \\}\\), chamado conjunto vazio, que não possui elementos.\nÉ possível que os elementos de um conjunto sejam eles próprios conjuntos. Por exemplo, \\(D = \\{ \\{ 1, 2\\}, 3 \\}\\) é um conjunto que contém o conjunto \\(\\{ 1, 2\\}\\) e o número \\(3\\)\n\n\n\n\n\n\n\n\n\n\nDefinição B.2 (Relação de pertença) Se \\(a\\) é um elemento de \\(A\\), expressamos essa condição como \\(a \\in A\\). Caso contrário, expressamos que \\(a\\) não é um elemento de \\(A\\) com \\(a \\notin A\\). Na teoria dos conjuntos, \\(\\in\\) é conhecido como a relação “é um elemento de”.\n\n\n\n\n\n\\(E = \\{ x \\in \\Omega: x \\text{ é um cachorro} \\}\\) onde \\(E\\) é o conjunto que contém todos os \\(x\\) que são cachorros. Nesse caso, \\(P(x)\\) refere-se a ter a propriedade de ser um cachorro e \\(\\Omega\\) pode ser o conjunto dos seres vivos.\n\\(F = \\{ x \\in \\mathbb{N} : x &gt; 5 \\}\\) onde \\(F\\) contém todos os números maiores que \\(5\\) que são números naturais. Nesse caso, \\(P(x)\\) refere-se a todos os \\(x\\) maiores que \\(5\\) e \\(\\Omega\\) é o conjunto dos números naturais.\n\n\n\nDefinição B.3 (Subconjunto) Um conjunto \\(A\\) é um subconjunto de um conjunto \\(B\\) se todos os elementos de \\(A\\) também sejam elementos de \\(B\\). Essa condição pode ser expressa através da notação \\(A \\subseteq B\\). Por outro lado, se existir um elemento que pertença a \\(A\\), mas não pertença a \\(B\\), representamos essa situação como \\(A \\nsubseteq B\\). Na teoria dos conjuntos, \\(\\subseteq\\) é conhecido como a relação de “inclusão”.\n\n\n\n\n\n\nDefinição B.4 (Igualdade de conjuntos) Com base em Definição B.3 podemos estabelecer uma definição equivalente para a igualdade de conjuntos. Dois conjuntos, \\(A\\) e \\(B\\), são considerados iguais, \\(A = B\\), se e somente se \\(A \\subseteq B\\) e \\(B \\subseteq A\\). Em outras palavras, ambos os conjuntos devem conter exatamente os mesmos elementos para serem considerados iguais.",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Teoria ingênua dos conjuntos</span>"
    ]
  },
  {
    "objectID": "naive_set_theory.html#operações-com-conjuntos",
    "href": "naive_set_theory.html#operações-com-conjuntos",
    "title": "Apêndice B — Teoria ingênua dos conjuntos",
    "section": "B.2 Operações com conjuntos",
    "text": "B.2 Operações com conjuntos\n\nDefinição B.5 (União de conjuntos) A união de dois conjuntos \\(A\\) e \\(B\\), denotada por \\(A \\cup B\\), é o conjunto de todos os elementos que estão em \\(A\\) ou em \\(B\\). \\(A \\cup B\\) também é um conjunto e pode ser definido usando notação construtor de conjuntos como \\(A \\cup B = \\{x \\in \\Omega : x \\in A \\textbf{ ou } x \\in B \\}\\)\n\nA Figura B.2 ilustra a Definição B.5 usando um diagrama de Venn.\n\n\n\n\n\n\n\n\nFigura B.2: \\(A \\cup B\\) representado por um diagrama de Venn onde \\(\\Omega\\) é o universo de discurso\n\n\n\n\n\nPor exemplo, se \\(A = \\{ 1, 2 \\}\\) e \\(H = \\{ 2, 3 \\}\\), então \\(A \\cup H = \\{ 1, 2, 3 \\}\\). Em , utilizando o pacote sets, o operador | é utilizado para representar a união, \\(\\cup\\), de dois conjuntos da seguinte maneira:\n\nH &lt;- set(2, 3)\nA | H\n#&gt; {1, 2, 3}\n\n\nDefinição B.6 (Interseção de conjuntos) A interseção de dois conjuntos \\(A\\) e \\(B\\), denotada por \\(A \\cap B\\), é o conjunto de todos os elementos que estão em \\(A\\) e em \\(B\\). \\(A \\cap B\\) também é um conjunto e pode ser definido usando notação construtor de conjuntos como \\(A \\cap B = \\{ x \\in \\Omega : x \\in A \\textbf{ e } x \\in B \\}\\).\n\nA Figura B.3 ilustra a Definição B.6 usando um diagrama de Venn.\n\n\n\n\n\n\n\n\nFigura B.3: \\(A \\cap B\\) representado por um diagrama de Venn onde \\(\\Omega\\) é o universo de discurso\n\n\n\n\n\nPor exemplo, se \\(A = \\{ 1, 2 \\}\\) e \\(H = \\{ 2, 3 \\}\\), então \\(A \\cap H = \\{ 2 \\}\\). Em , utilizando o pacote sets, o operador & é utilizado para representar a interseção, \\(\\cap\\), de dois conjuntos da seguinte maneira:\n\nA & H\n#&gt; {2}\n\n\nDefinição B.7 (Diferença de conjuntos) A diferença de dois conjuntos \\(A\\) e \\(B\\), denotada por \\(A \\setminus B\\), é o conjunto de todos os elementos que pertencem a \\(A\\), mas não a \\(B\\). \\(A \\setminus B\\) também é um conjunto e pode ser definido usando notação construtor de conjuntos como \\(A \\setminus B = \\{ x \\in \\Omega : x \\in A \\text{ e } x \\notin B \\}\\).\n\nA Figura B.4 ilustra a Definição B.7 usando um diagrama de Venn.\n\n\n\n\n\n\n\n\nFigura B.4: \\(A \\setminus B\\) representado por um diagrama de Venn onde \\(\\Omega\\) é o universo de discurso\n\n\n\n\n\nPor exemplo, se \\(A = \\{ 1, 2 \\}\\) e \\(H = \\{ 2, 3 \\}\\), então \\(A \\setminus H = \\{ 1 \\}\\) e \\(H \\setminus A = \\{ 3 \\}\\). Em , utilizando o pacote sets, o operador - é utilizado para representar a diferença, \\(\\setminus\\), de dois conjuntos da seguinte maneira:\n\nA - H\n#&gt; {1}\nH - A\n#&gt; {3}\n\n\nDefinição B.8 (Complemento de um conjunto) Se \\(A\\) e \\(\\Omega\\) são conjuntos, onde e \\(\\Omega\\) é o universo de discurso, o complemento de \\(A\\), denotado por \\(A^c\\), é o conjunto \\(\\Omega \\setminus A\\). Ou seja, \\(A^c = \\{x \\in \\Omega: x \\notin A \\text{ e } A \\subseteq \\Omega \\}\\).\n\nA Figura B.5 ilustra a Definição B.8 usando um diagrama de Venn.\n\n\n\n\n\n\n\n\nFigura B.5: \\(A^c\\) representado por um diagrama de Venn onde \\(\\Omega\\) é o universo de discurso\n\n\n\n\n\nPor exemplo, se \\(A = \\{ 1, 2 \\}\\) e \\(\\Omega = \\{ 1, 2, 3, 4 \\}\\), então \\(A^c = \\{ 3, 4 \\}\\). Em , utilizando o pacote sets, podemos determinar \\(A^c\\) da seguinte maneira:\n\nomega &lt;- set(1, 2, 3, 4)\nomega - A\n#&gt; {3, 4}",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Teoria ingênua dos conjuntos</span>"
    ]
  },
  {
    "objectID": "naive_set_theory.html#o-conjunto-vazio-e-o-conjunto-potência",
    "href": "naive_set_theory.html#o-conjunto-vazio-e-o-conjunto-potência",
    "title": "Apêndice B — Teoria ingênua dos conjuntos",
    "section": "B.3 O conjunto vazio e o conjunto potência",
    "text": "B.3 O conjunto vazio e o conjunto potência\nO conjunto vazio, \\(\\emptyset\\), tem certas características que podem parecer contraintuitivas. Em primeiro lugar, só pode haver um conjunto vazio porque quaisquer dois conjuntos que não contenham nenhum elemento são idênticos. Conforme declarado na Definição B.4, conjuntos são considerados iguais se eles têm os mesmos elementos. Como ambos os conjuntos vazios não contêm elementos, eles são considerados o mesmo conjunto.\nOutra propriedade aparentemente contraintuitiva é que o conjunto vazio é um subconjunto de todos os conjuntos. Se temos um conjunto \\(A\\), e afirmamos que o conjunto vazio não é um subconjunto de \\(A\\), denotado por \\(\\emptyset \\subseteq A\\), então, de acordo com a Definição B.3, deve existir um elemento que pertença a \\(\\emptyset\\), mas não a \\(A\\). No entanto, como o conjunto vazio não tem nenhum elemento, é impossível que um elemento pertença a \\(\\emptyset\\). Portanto, a única maneira de evitar uma contradição é aceitar que o conjunto vazio é um subconjunto de todos os conjuntos, denotado por \\(\\emptyset \\subseteq A\\).\nPodemos resumir os resultados acima da seguinte maneira:\n\nTeorema B.1 (Unicidade do conjunto vazio) Só existe um conjunto vazio. Em outras palavras, se \\(\\emptyset\\) e \\(\\emptyset^{'}\\) são ambos conjuntos vazios, então \\(\\emptyset\\) é igual a \\(\\emptyset^{'}\\), \\(\\emptyset = \\emptyset^{'}\\).\n\n\nTeorema B.2 (Propriedade de subconjunto do conjunto vazio) O conjunto vazio é um subconjunto de todos os conjuntos. Para qualquer conjunto \\(A\\), o conjunto vazio, \\(\\emptyset\\), é um subconjunto de \\(A\\), \\(\\emptyset \\subseteq A\\).\n\nHá também um conjunto chamado conjunto das potências. O conjunto das potências de um conjunto \\(A\\), denotado como \\(\\mathcal{P}(A)\\), é um conjunto que contém todos os subconjuntos de \\(A\\). Podemos defini-lo como:\n\nDefinição B.9 (Conjunto das potências) Se \\(A\\) é um conjunto, então o conjunto que contém todos os subconjuntos de \\(A\\), denotado como \\(\\mathcal{P}(A)\\), é definido como \\(\\mathcal{P}(A) = \\{ B: B \\subseteq A \\}\\).\n\nPor exemplo, se \\(A = \\{ 1, 2 \\}\\) então \\(\\mathcal{P}(A) = \\{ \\emptyset, \\{ 1 \\}, \\{ 2 \\}, A \\} = \\{ \\emptyset, \\{ 1 \\}, \\{ 2 \\}, \\{ 1,2 \\} \\}\\) porque \\(\\emptyset \\subseteq A\\) pelo Teorema B.2, \\(\\{ 1 \\} \\subseteq A\\), \\(\\{ 2 \\} \\subseteq A\\) e \\(A = \\{ 1, 2 \\} \\subseteq A\\). Em , podemos construir o conjunto das potências de um conjunto \\(A\\), \\(\\mathcal{P}(A)\\), como 2^A utilizando o pacote sets da seguinte maneira:\n\npotencia_A &lt;- 2^A\npotencia_A\n#&gt; {{}, {1}, {2}, {1, 2}}\n\n\n\n\n\nHalmos, Paul R. 2001. Teoria ingenua dos conjuntos. Rio de Janeiro: Editora Ciencia Moderna.",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Teoria ingênua dos conjuntos</span>"
    ]
  },
  {
    "objectID": "naive_set_theory.html#footnotes",
    "href": "naive_set_theory.html#footnotes",
    "title": "Apêndice B — Teoria ingênua dos conjuntos",
    "section": "",
    "text": "Para uma apresentação detalhada e clara da teoria dos conjuntos usando um sistema de axiomas, você pode consultar (Halmos 2001)↩︎\n\\(\\Omega\\) é chamado Ômega↩︎\nUm diagrama de Venn é uma ferramenta visual que utiliza formas fechadas para representar conjuntos e ilustrar como seus elementos se relacionam.↩︎",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Teoria ingênua dos conjuntos</span>"
    ]
  }
]